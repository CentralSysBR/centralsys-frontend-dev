diff --git a/src/services/api.ts b/src/services/api.ts
index 1111111..2222222 100644
--- a/src/services/api.ts
+++ b/src/services/api.ts
@@ -8,7 +8,47 @@
   withCredentials: true,
 });
 
+/**
+ * Separate client WITHOUT interceptors to avoid infinite loops when refreshing.
+ */
+const refreshClient = axios.create({
+  baseURL,
+  withCredentials: true,
+});
+
 type RetriableRequest = InternalAxiosRequestConfig & { _retry?: boolean };
+
+let refreshPromise: Promise<void> | null = null;
+let refreshDisabled = false;
+
+function isAuthEndpoint(url: string | undefined): boolean {
+  if (!url) return false;
+  return (
+    url.includes("/auth/login") ||
+    url.includes("/auth/logout") ||
+    url.includes("/auth/refresh") ||
+    url.includes("/auth/me")
+  );
+}
+
+async function refreshSessionOnce(): Promise<void> {
+  if (refreshDisabled) throw new Error("refresh_disabled");
+  if (!refreshPromise) {
+    refreshPromise = refreshClient
+      .post("/auth/refresh")
+      .then(() => {
+        refreshDisabled = false;
+      })
+      .catch((err) => {
+        refreshDisabled = true; // stop thrashing until explicit login
+        throw err;
+      })
+      .finally(() => {
+        refreshPromise = null;
+      });
+  }
+  await refreshPromise;
+}
 
 api.interceptors.response.use(
   (response) => response,
@@ -16,17 +56,19 @@
     const status = error.response?.status;
     const original = error.config as RetriableRequest | undefined;
 
-    if (status === 401 && original && !original._retry) {
-      original._retry = true;
-      try {
-        await api.post("/auth/refresh");
-        return api(original);
-      } catch {
-        // keep bubbling; caller handles redirect
-      }
+    // Never refresh on auth endpoints (prevents recursion / infinite loops)
+    if (status !== 401 || !original || original._retry || isAuthEndpoint(original.url)) {
+      return Promise.reject(error);
     }
 
-    return Promise.reject(error);
+    original._retry = true;
+
+    try {
+      await refreshSessionOnce();
+      return api(original);
+    } catch {
+      return Promise.reject(error);
+    }
   }
 );
 
